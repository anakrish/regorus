# Copyright (c) Microsoft Corporation.
# Licensed under the MIT License.

# Empty Collections Loop Test Suite
# Tests behavior of various loop types over empty collections
# 1. Comprehensions should evaluate to their empty versions
# 2. some..in should evaluate to false  
# 3. every should evaluate to true

cases:
  - note: existential_empty_array
    description: Existential quantification (some) on empty array should return false
    example_rego: |
      # some x in []
      # x > 0  # false - no elements to satisfy condition
    literals:
      - 0  # comparison value
    instruction_params:
      loop_params:
        - mode: "Any"
          collection: 0
          key_reg: 4
          value_reg: 5
          result_reg: 6
          body_start: 2
          loop_end: 6
    instructions:
      - "ArrayNew { dest: 0 }"              # Create empty array in register 0
      - "LoopStart { params_index: 0 }"
      - "Load { dest: 7, literal_idx: 0 }"  # Load comparison value 0
      - "Gt { dest: 8, left: 5, right: 7 }" # Check if current value > 0
      - "AssertCondition { condition: 8 }"  # Assert the condition
      - "LoopNext { body_start: 2, loop_end: 6 }"
      - "Return { value: 6 }"               # Return false for empty collection
    want_result: false

  - note: universal_empty_array
    description: Universal quantification (every) on empty array should return true  
    example_rego: |
      # every x in []
      # x > 0  # true - vacuously true (no elements to violate condition)
    literals:
      - 0  # comparison value
    instruction_params:
      loop_params:
        - mode: "Every"
          collection: 0
          key_reg: 4
          value_reg: 5
          result_reg: 6
          body_start: 2
          loop_end: 6
    instructions:
      - "ArrayNew { dest: 0 }"              # Create empty array in register 0
      - "LoopStart { params_index: 0 }"
      - "Load { dest: 7, literal_idx: 0 }"  # Load comparison value 0
      - "Gt { dest: 8, left: 5, right: 7 }" # Check if current value > 0
      - "AssertCondition { condition: 8 }"  # Assert the condition
      - "LoopNext { body_start: 2, loop_end: 6 }"
      - "Return { value: 6 }"               # Return true for empty collection (vacuously true)
    want_result: true

  - note: array_comprehension_empty
    description: Array comprehension on empty collection should return empty array
    example_rego: |
      # [x + 1 | x = []; true]  # []
      # Transform each element by adding 1
    literals:
      - 1  # value to add
    instruction_params:
      loop_params:
        - mode: "ArrayComprehension"
          collection: 0
          key_reg: 4
          value_reg: 5
          result_reg: 1
          body_start: 3
          loop_end: 8
    instructions:
      - "ArrayNew { dest: 0 }"              # Create empty input array in register 0
      - "ArrayNew { dest: 1 }"              # Create empty result array in register 1  
      - "LoopStart { params_index: 0 }"
      - "Load { dest: 6, literal_idx: 0 }"  # Load 1 into register 6
      - "Add { dest: 7, left: 5, right: 6 }" # Add 1 to current value
      - "ArrayPush { arr: 1, value: 7 }"    # Push result to output array
      - "LoadBool { dest: 8, value: true }" # Load true (condition always passes)
      - "AssertCondition { condition: 8 }"  # Assert true condition
      - "LoopNext { body_start: 3, loop_end: 8 }"
      - "Return { value: 1 }"               # Return the result array (should be empty)
    want_result: []

  - note: set_comprehension_empty
    description: Set comprehension on empty collection should return empty set
    example_rego: |
      # {x + 1 | x = []; true}  # set()
      # Transform each element by adding 1 into a set
    literals:
      - 1  # value to add
    instruction_params:
      loop_params:
        - mode: "SetComprehension"
          collection: 0
          key_reg: 4
          value_reg: 5
          result_reg: 1
          body_start: 3
          loop_end: 8
    instructions:
      - "ArrayNew { dest: 0 }"              # Create empty input array in register 0
      - "SetNew { dest: 1 }"                # Create empty result set in register 1
      - "LoopStart { params_index: 0 }"
      - "Load { dest: 6, literal_idx: 0 }"  # Load 1 into register 6
      - "Add { dest: 7, left: 5, right: 6 }" # Add 1 to current value
      - "SetAdd { set: 1, value: 7 }"       # Add result to output set
      - "LoadBool { dest: 8, value: true }" # Load true (condition always passes)
      - "AssertCondition { condition: 8 }"  # Assert true condition
      - "LoopNext { body_start: 3, loop_end: 8 }"
      - "Return { value: 1 }"               # Return the result set (should be empty)
    want_result: 
      set!: []  # Set serializes as empty array

  - note: object_comprehension_empty
    description: Object comprehension on empty collection should return empty object
    example_rego: |
      # {k: v + 1 | some k, v in {}; true}  # {}
      # Transform each key-value pair 
    literals:
      - 1  # value to add
    instruction_params:
      loop_params:
        - mode: "ObjectComprehension"
          collection: 0
          key_reg: 4
          value_reg: 5
          result_reg: 1
          body_start: 3
          loop_end: 8
    instructions:
      - "ObjectNew { dest: 0 }"             # Create empty input object in register 0
      - "ObjectNew { dest: 1 }"             # Create empty result object in register 1
      - "LoopStart { params_index: 0 }"
      - "Load { dest: 6, literal_idx: 0 }"  # Load 1 into register 6  
      - "Add { dest: 7, left: 5, right: 6 }" # Add 1 to current value
      - "ObjectSet { obj: 1, key: 4, value: 7 }" # Set key: (value + 1) in result object
      - "LoadBool { dest: 8, value: true }" # Load true (condition always passes)
      - "AssertCondition { condition: 8 }"  # Assert true condition
      - "LoopNext { body_start: 3, loop_end: 8 }"
      - "Return { value: 1 }"               # Return the result object (should be empty)
    want_result: {}

  - note: existential_empty_set
    description: Existential quantification on empty set should return false
    example_rego: |
      # some x in set()
      # x > 0  # false - no elements in set
    literals:
      - 0  # comparison value
    instruction_params:
      loop_params:
        - mode: "Any"
          collection: 0
          key_reg: 4
          value_reg: 5
          result_reg: 6
          body_start: 2
          loop_end: 6
    instructions:
      - "SetNew { dest: 0 }"                # Create empty set in register 0
      - "LoopStart { params_index: 0 }"
      - "Load { dest: 7, literal_idx: 0 }"  # Load comparison value 0
      - "Gt { dest: 8, left: 5, right: 7 }" # Check if current value > 0
      - "AssertCondition { condition: 8 }"  # Assert the condition
      - "LoopNext { body_start: 2, loop_end: 6 }"
      - "Return { value: 6 }"               # Return false for empty set
    want_result: false

  - note: universal_empty_object
    description: Universal quantification on empty object should return true
    example_rego: |
      # every k, v in {}
      # v > 0  # true - vacuously true (no key-value pairs to violate condition)
    literals:
      - 0  # comparison value
    instruction_params:
      loop_params:
        - mode: "Every"
          collection: 0
          key_reg: 4
          value_reg: 5
          result_reg: 6
          body_start: 2
          loop_end: 6
    instructions:
      - "ObjectNew { dest: 0 }"             # Create empty object in register 0
      - "LoopStart { params_index: 0 }"
      - "Load { dest: 7, literal_idx: 0 }"  # Load comparison value 0
      - "Gt { dest: 8, left: 5, right: 7 }" # Check if current value > 0
      - "AssertCondition { condition: 8 }"  # Assert the condition
      - "LoopNext { body_start: 2, loop_end: 6 }"
      - "Return { value: 6 }"               # Return true for empty object (vacuously true)
    want_result: true

  - note: nested_empty_comprehensions
    description: Nested comprehensions with empty collections
    example_rego: |
      # [[y | y = []; true] | x = []; true]  # []
      # Nested array comprehension where both inner and outer collections are empty
    literals: []
    instruction_params:
      loop_params:
        - mode: "ArrayComprehension"
          collection: 0
          key_reg: 2
          value_reg: 3
          result_reg: 1
          body_start: 3
          loop_end: 14
        - mode: "ArrayComprehension"
          collection: 6
          key_reg: 8
          value_reg: 9
          result_reg: 7
          body_start: 6
          loop_end: 10
    instructions:
      - "ArrayNew { dest: 0 }"              # Create empty outer array in register 0
      - "ArrayNew { dest: 1 }"              # Create empty result array in register 1
      - "LoopStart { params_index: 0 }"
      # Inner array comprehension (for each x in outer empty array)
      - "ArrayNew { dest: 6 }"              # Create empty inner array in register 6
      - "ArrayNew { dest: 7 }"              # Create result for inner comprehension in register 7
      - "LoopStart { params_index: 0 }"
      - "ArrayPush { arr: 7, value: 9 }"    # Push inner value to inner result (never executes)
      - "LoadBool { dest: 10, value: true }" # Load true
      - "AssertCondition { condition: 10 }" # Assert true condition for inner loop
      - "LoopNext { body_start: 6, loop_end: 10 }"
      - "ArrayPush { arr: 1, value: 7 }"    # Push inner result to outer result
      - "LoadBool { dest: 11, value: true }" # Load true
      - "AssertCondition { condition: 11 }" # Assert true condition for outer loop  
      - "LoopNext { body_start: 3, loop_end: 14 }"
      - "Return { value: 1 }"               # Return the nested result (should be empty)
    want_result: []
