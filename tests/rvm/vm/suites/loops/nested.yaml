name: "Nested Loops Test Suite"
description: "Test various combinations and levels of nesting for different looping constructs"

cases:
  - note: "simple_nested_comprehension"
    description: "Test simple nested array comprehension"
    example_rego: |
      [[x | x := [1, 2][_]] | _ := [1, 2][_]]
    literals:
      - 1
      - 2
    instruction_params:
      loop_params:
        - mode: "ArrayComprehension"
          collection: 0
          key_reg: 7
          value_reg: 8
          result_reg: 12
          body_start: 11
          loop_end: 16
        - mode: "ArrayComprehension"
          collection: 3
          key_reg: 9
          value_reg: 10
          result_reg: 11
          body_start: 12
          loop_end: 14
    instructions:
      - "ArrayNew { dest: 0 }"              # Create outer input array [1, 2]
      - "Load { dest: 1, literal_idx: 0 }"  # Load 1
      - "ArrayPush { arr: 0, value: 1 }"    # Push 1 to outer array
      - "Load { dest: 2, literal_idx: 1 }"  # Load 2
      - "ArrayPush { arr: 0, value: 2 }"    # Push 2 to outer array
      - "ArrayNew { dest: 3 }"              # Create inner source array [1, 2]
      - "Load { dest: 4, literal_idx: 0 }"  # Load 1
      - "ArrayPush { arr: 3, value: 4 }"    # Push 1 to inner array
      - "Load { dest: 5, literal_idx: 1 }"  # Load 2
      - "ArrayPush { arr: 3, value: 5 }"    # Push 2 to inner array
      - "LoopStart { params_index: 0 }"
      # Outer comprehension body starts at index 11
      - "LoopStart { params_index: 1 }"
      # Inner comprehension body starts at index 12
      - "ArrayPush { arr: 11, value: 10 }"  # Index 12: Push x to inner result array (auto-created by VM)
      - "LoopNext { body_start: 12, loop_end: 14 }"  # Index 13: Continue inner loop
      # Inner loop ends at index 14, execution continues to index 14
      - "ArrayPush { arr: 12, value: 11 }"   # Index 14: Push inner array result to outer result
      - "LoopNext { body_start: 11, loop_end: 16 }"  # Index 15: Continue outer loop  
      # Outer loop ends at index 16, execution continues to index 16
      - "Return { value: 12 }"               # Index 16: Return final result
    want_result: [[1, 2], [1, 2]]

  - note: "some_nested_comprehension"
    description: "Test some with nested array comprehension"
    example_rego: |
      some [1, 2][_] == [x | x := [1, 2, 3][_]; x > 1][_]
    literals:
      - 1
      - 2
      - 3
    instruction_params:
      loop_params:
        - mode: "Any"
          collection: 0
          key_reg: 7
          value_reg: 8
          result_reg: 9
          body_start: 13
          loop_end: 21
        - mode: "ArrayComprehension"
          collection: 3
          key_reg: 10
          value_reg: 11
          result_reg: 12
          body_start: 14
          loop_end: 19
    instructions:
      - "ArrayNew { dest: 0 }"              # Create collection [1, 2]
      - "Load { dest: 1, literal_idx: 0 }"  # Load 1
      - "ArrayPush { arr: 0, value: 1 }"
      - "Load { dest: 2, literal_idx: 1 }"  # Load 2
      - "ArrayPush { arr: 0, value: 2 }"
      - "ArrayNew { dest: 3 }"              # Create inner source [1, 2, 3]
      - "Load { dest: 4, literal_idx: 0 }"  # Load 1
      - "ArrayPush { arr: 3, value: 4 }"
      - "Load { dest: 5, literal_idx: 1 }"  # Load 2
      - "ArrayPush { arr: 3, value: 5 }"
      - "Load { dest: 6, literal_idx: 2 }"  # Load 3
      - "ArrayPush { arr: 3, value: 6 }"
      - "LoopStart { params_index: 0 }"
      # Outer some body
      - "LoopStart { params_index: 1 }"
      # Inner comprehension body - check if x > 1
      - "Load { dest: 13, literal_idx: 0 }"  # Load 1 for comparison
      - "Gt { dest: 14, left: 11, right: 13 }"  # Check x > 1
      - "AssertCondition { condition: 14 }"  # Assert x > 1 (only add if true)
      - "ArrayPush { arr: 12, value: 11 }"   # Add x to result if x > 1
      - "LoopNext { body_start: 14, loop_end: 19 }"
      # After inner comprehension, check if some value matches
      - "Eq { dest: 15, left: 8, right: 12 }"   # Compare outer value with inner array
      - "LoopNext { body_start: 13, loop_end: 21 }"
      - "Return { value: 9 }"
    want_result: true

  - note: "nested_with_condition"
    description: "Test nested loops with conditional logic"
    example_rego: |
      [x | x := [1, 2, 3][_]; x > 1]
    literals:
      - 1
      - 2
      - 3
    instruction_params:
      loop_params:
        - mode: "ArrayComprehension"
          collection: 0
          key_reg: 4
          value_reg: 5
          result_reg: 6
          body_start: 8
          loop_end: 13
    instructions:
      - "ArrayNew { dest: 0 }"              # Create input array [1, 2, 3]
      - "Load { dest: 1, literal_idx: 0 }"  # Load 1
      - "ArrayPush { arr: 0, value: 1 }"    # Push 1 to array
      - "Load { dest: 2, literal_idx: 1 }"  # Load 2
      - "ArrayPush { arr: 0, value: 2 }"    # Push 2 to array
      - "Load { dest: 3, literal_idx: 2 }"  # Load 3
      - "ArrayPush { arr: 0, value: 3 }"    # Push 3 to array
      - "LoopStart { params_index: 0 }"
      # Comprehension body with condition (index 8)
      - "Load { dest: 7, literal_idx: 0 }"  # Load 1
      - "Gt { dest: 8, left: 5, right: 7 }" # x > 1
      - "AssertCondition { condition: 8 }" # Assert x > 1 (only add if true)
      - "ArrayPush { arr: 6, value: 5 }"    # Push x to result if condition true
      - "LoopNext { body_start: 8, loop_end: 13 }"
      - "Return { value: 6 }"
    want_result: [2, 3]
